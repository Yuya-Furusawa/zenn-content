---
title: "ViteでDevとProdの挙動が異なる件を調べた"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vite", "react", "typescript"]
published: false
---

Viteを用いたReact開発を行っている際、`vite dev`で立ち上げたDevモードと実際にデプロイしたProdモードで挙動が異なるという問題が発生したので、その原因究明メモです。

# そもそもViteとは

Viteはフロントエンド向けビルドツールです。2020年に登場しましたが2024年現在ではもはやデファクトスタンダードのような立ち位置になっています。

特徴としては高速な開発サーバー立ち上げと高速なHMRです。ブラウザ上で直接実行できるというESModuleの特性をフル活用し、webpackのように全体をバンドルしてから開発サーバを立ち上げるのではなく、まず開発サーバを立ち上げその後ブラウザ上で直接モジュールを読み込んでいくことで高速な開発サーバ起動を実現します。また、事前バンドルという過程で外部パッケージ等をesbuildでESModule形式にビルドしておきそれをブラウザ上で積極的にキャッシュすることも行います。

# 発生した問題

React + Viteで以下のようなコードを書いていました。

```ts
...
import * as dayjs from "dayjs";

const Component = () => {
  ...
  return (
    <>
      ...
      dayjs("2024-01-01")
      ...
    </>
  )
}
```

以下の点がポイントです。
- dayjs（CommonJS形式）をnamespace import（`import *`）している
- dayjsを関数として呼び出している

このとき、Devモードでは問題なく動作したものの、ビルド成果物を実行したら`xx is not function`というエラーが発生しました。どうやらビルド成果物を実行した際に関数でない何かしらのオブジェクトが関数呼び出しされていることが原因のようです。

## なぜ問題が発生したのか

原因はシンプルで、namespace objectであるdayjsを関数呼び出ししてるのが問題です。ESModuleにおいてはnamespace importするとモジュール全体が一つのオブジェクトとしてimportされます。objectですのでもちろん関数呼び出しをすることができません。Day.jsの公式Docsには（特定のtsconfigの設定がない限り）namespace importをするように記載があったのでそれに従ったのですが、誤りだったようです。

## 問題の解決策

解決策としてはnamespace importをやめてdefault importにすればOKです。つまり以下のようにコードを修正します。

```ts
import dayjs from "dayjs";

// 以下同じ
```

default importをすることによって、`module.exports`を通じてexportされたものを直接importすることができます。Dayjsの場合、`dayjs`関数が直接exportされているので、default importすることによってそれをそのまま関数として利用できます。

もしくはnamespace importのままで`dayjs.default("2024-01-01")`と呼び出す形でもOKです（この場合`dayjs`はオブジェクトであり、`default`というフィールドが関数にあたる）。

## tsconfigの設定でそもそも防げた

そもそもIDEツール上でエラーを出すためにはtsconfig.jsonの設定を以下のようにすべきです。

```json
{
  "compilerOptions": {
    ...
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    ...
}
```

`esModuleInterop`はESModuleとCommonJSの互換性を確保するためのオプションです。これを有効にすることでCommonJSをESModuleに適合した形でimportすることができます。そのため、有効にした段階でIDE上でエラーを表示してくれるでしょう。`allowSyntheticDefaultImports`は型チェックにのみ影響を与えるフラグです。`esModuleInterop`が`true`であれば自動的に`true`になります。

以上の通り、原因自体はシンプルでそりゃそうだなという感じなのですが、ここで問題なのは **なぜDevでは正常に動きProdではエラーとなったのか？** です。

# なぜDevとProdで挙動が変わったのか？

結論から言うとViteはDevモードにおいてnamespace importをdefault importに置換しているためにエラーが発生しないようになっています。事前バンドルフェーズにおいてESModule形式に変換されたdayjsライブラリをdefault importでimportしているためエラーが発生しません。

実際にDev Toolのイニシエーターを見てみると、以下のようにnamespace importがdefault importになっていることが分かります。

![](https://storage.googleapis.com/zenn-user-upload/f87726590df3-20240514.png)

次にVite内部のコードを見てみます。以下の通りnamespace importがdefault importに明示的に書き換えられています。

https://github.com/vitejs/vite/blob/6cccef78a52492c24d9b28f3a1784824f34f5cc3/packages/vite/src/node/plugins/importAnalysis.ts#L1000-L1024

CommonJSとESModuleの互換性を保つために、開発者がimport形式を意識しなくても良くするために、Viteはこのような処理を行っていると考えられます。

# 教訓

ViteでDevモードとProdモードで挙動が異なる可能性があることが分かりました。ではViteを使うのをやめるべきなのでしょうか？ここから得られる教訓は2つです。

1. `vite dev`だけじゃなくて`vite preview`もしよう

`vite build`でビルドしたものを`vite preview`でビルド成果物を実行することができます。実際のビルド成果物を確認することができるので本番に近いものを試すことができます。今回の問題も`vite preview`しておけばローカルでも気づくことができました（もっともビルド時にwarningが出るのですが）。

2. tsconfigの設定を適切に設定しよう

今回の問題は先述の通りtsconfigを適切に設定しIDEツール上で型エラーにしてあげれば早期に気づくことが可能でした。なるべく型エラーの方に不具合を寄せてあげてDev/ProdのVite固有の問題にはしないであげることが重要そうな気がします。

# 参照

- https://github.com/vitejs/vite/issues/15542
- https://qiita.com/eyuta/items/fccebb53d88798c76da5
- https://www.typescriptlang.org/tsconfig/#esModuleInterop
